self: super:

let pkgs = self.pkgs;
in {
  buildCmDotnetModule = ({ name
    , projectFile ? ("src/" + args.name + "/" + args.name + ".fsproj")
    , version ? "0.0.1", src ? ./.
    , nugetDeps ? ./nix + "/${args.name}" + ".deps.nix", ... }@args:
    pkgs.callPackage pkgs.buildDotnetModule args);

  buildPaketDotnetModule = with pkgs;
    ({ name ? "${args.pname}-${args.version}", pname ? name
        # The packages project file, which contains instructions on how to compile it. This can be an array of multiple project files as well.
      , projectFile ? null
        # The project file to run unit tests against. This is usually referenced in the regular project file, but sometimes it needs to be manually set.
        # It gets restored and build, but not installed. You may need to regenerate your nuget lockfile after setting this.
      , testProjectFile ? ""
        # The NuGet dependency file. This locks all NuGet dependency versions, as otherwise they cannot be deterministically fetched.
        # This can be generated by running the `passthru.fetch-deps` script.
      , nugetDeps ? ./nix + "/${args.name}" + ".deps.nix", ... }@args:
      (callPackage buildCmDotnetModule args).overrideAttrs
      (finalAttrs: previousAttrs: {
        passthru = previousAttrs.passthru // {
          args = builtins.trace (args "");
          # This is originally sourced from https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/dotnet/build-dotnet-module/default.nix
          fetch-deps = let
            # Derivations may set flags such as `--runtime <rid>` based on the host platform to avoid restoring/building nuget dependencies they dont have or dont need.
            # This introduces an issue; In this script we loop over all platforms from `meta` and add the RID flag for it, as to fetch all required dependencies.
            # The script would inherit the RID flag from the derivation based on the platform building the script, and set the flag for any iteration we do over the RIDs.
            # That causes conflicts. To circumvent it we remove all occurances of the flag.
            flags = let
              hasRid = flag:
                lib.any (v: v) (map (rid: lib.hasInfix rid flag) (lib.attrValues
                  previousAttrs.dotnet-sdk.runtimeIdentifierMap));
            in builtins.filter (flag: !(hasRid flag))
            (previousAttrs.dotnetFlags ++ previousAttrs.dotnetRestoreFlags);
          in writeShellScript "fetch-${pname}-deps" ''
            set -euo pipefail

            export PATH="${
              lib.makeBinPath [
                coreutils
                previousAttrs.dotnet-sdk
                (nuget-to-nix.override { inherit (previousAttrs.dotnet-sdk) ; })
              ]
            }"

            for arg in "$@"; do
                case "$arg" in
                    --keep-sources|-k)
                        keepSources=1
                        shift
                        ;;
                    --help|-h)
                        echo "usage: $0 [--keep-sources] [--help] <output path>"
                        echo "    <output path>   The path to write the lockfile to. A temporary file is used if this is not set"
                        echo "    --keep-sources  Dont remove temporary directories upon exit, useful for debugging"
                        echo "    --help          Show this help message"
                        exit
                        ;;
                esac
            done

            export tmp=$(mktemp -td "${pname}-tmp-XXXXXX")
            HOME=$tmp/home

            exitTrap() {
                test -n "''${ranTrap-}" && return
                ranTrap=1
                if test -n "''${keepSources-}"; then
                    echo -e "Path to the source: $tmp/src\nPath to the fake home: $tmp/home"
                else
                    rm -rf "$tmp"
                fi
                # Since mktemp is used this will be empty if the script didnt succesfully complete
                ! test -s "$depsFile" && rm -rf "$depsFile"
            }

            trap exitTrap EXIT INT TERM

            dotnetRestore() {
                local -r project="''${1-}"

                dotnet paket restore \
                    --project ''${project-}
            }

            declare -a projectFiles=( ${toString (lib.toList projectFile)} )
            declare -a testProjectFiles=( ${
              toString (lib.toList testProjectFile)
            } )

            export DOTNET_NOLOGO=1
            export DOTNET_CLI_TELEMETRY_OPTOUT=1

            depsFile=$(realpath "''${1:-$(mktemp -t "${pname}-deps-XXXXXX.nix")}")
            mkdir -p "$tmp/nuget_pkgs"
            EXPORT NUGET_PACKAGES="$tmp/nuget_pkgs"

            storeSrc="${srcOnly finalAttrs}"
            src=$tmp/src
            cp -rT "$storeSrc" "$src"
            chmod -R +w "$src"

            cd "$src"
            echo "Restoring project..."

            dotnet tool restore

            (( ''${#projectFiles[@]} == 0 )) && dotnetRestore ""


            for project in ''${projectFiles[@]-} ''${testProjectFiles[@]-}; do
                dotnetRestore "$project" "$rid"
            done

            echo "Succesfully restored project"

            echo "Writing lockfile..."
            echo -e "# This file was automatically generated by passthru.fetch-deps.\n# Please dont edit it manually, your changes might get overwritten!\n" > "$depsFile"
            nuget-to-nix "$tmp/nuget_pkgs" "${sdkDeps}" >> "$depsFile"
            echo "Succesfully wrote lockfile to $depsFile"
          '';
        };
      }));
}
